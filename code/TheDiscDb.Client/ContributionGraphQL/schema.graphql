schema {
  query: ContributionQuery
  mutation: Mutation
}

scalar EncodedId

type ContributionQuery {
  contributions("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: UserContributionFilterInput order: [UserContributionSortInput!]): ContributionsConnection
  myContributions("Returns the first _n_ elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last _n_ elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: UserContributionFilterInput order: [UserContributionSortInput!]): MyContributionsConnection
}

type Mutation {
  addContribution(input: AddContributionInput!): AddContributionPayload!
  hashDisc(input: HashDiscInput!): HashDiscPayload!
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

enum UserContributionStatus {
  PENDING
  READY_FOR_REVIEW
  APPROVED
  CHANGES_REQUESTED
  REJECTED
  IMPORTED
}

type UserContributionDisc {
  id: Int!
  userContribution: UserContribution
  contentHash: String
  format: String
  name: String
  slug: String
  logsUploaded: Boolean!
  existingDiscPath: String
  items: [UserContributionDiscItem]
  encodedId: EncodedId!
}

type UserContributionDiscHashItem {
  id: Int!
  userContribution: UserContribution
  discHash: String
  index: Int!
  name: String
  creationTime: DateTime!
  size: Long!
  encodedId: EncodedId!
}

type UserContribution {
  id: Int!
  userId: String
  created: DateTime!
  status: UserContributionStatus!
  discs: [UserContributionDisc]
  hashItems: [UserContributionDiscHashItem]
  mediaType: String
  externalId: String
  externalProvider: String
  releaseDate: DateTime!
  asin: String
  upc: String
  frontImageUrl: String
  backImageUrl: String
  releaseTitle: String
  releaseSlug: String
  locale: String
  regionCode: String
  title: String
  year: String
  titleSlug: String
  encodedId: EncodedId!
}

type UserContributionDiscItem {
  id: Int!
  disc: UserContributionDisc
  name: String
  source: String
  duration: String
  size: String
  chapterCount: Int!
  segmentCount: Int!
  segmentMap: String
  type: String
  description: String
  season: String
  episode: String
  chapters: [UserContributionChapter]
  audioTracks: [UserContributionAudioTrack]
  encodedId: EncodedId!
}

type UserContributionChapter {
  id: Int!
  index: Int!
  title: String
  item: UserContributionDiscItem
  encodedId: EncodedId!
}

type UserContributionAudioTrack {
  id: Int!
  index: Int!
  title: String
  item: UserContributionDiscItem
  encodedId: EncodedId!
}

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

input UserContributionFilterInput {
  and: [UserContributionFilterInput!]
  or: [UserContributionFilterInput!]
  encodedId: EncodedIdOperationFilterInput
  userId: StringOperationFilterInput
  created: DateTimeOperationFilterInput
  status: UserContributionStatusOperationFilterInput
  discs: ListEncodedIdFilterTypeOfUserContributionDiscFilterInput
  hashItems: ListEncodedIdFilterTypeOfUserContributionDiscHashItemFilterInput
  mediaType: StringOperationFilterInput
  externalId: StringOperationFilterInput
  externalProvider: StringOperationFilterInput
  releaseDate: DateTimeOperationFilterInput
  asin: StringOperationFilterInput
  upc: StringOperationFilterInput
  frontImageUrl: StringOperationFilterInput
  backImageUrl: StringOperationFilterInput
  releaseTitle: StringOperationFilterInput
  releaseSlug: StringOperationFilterInput
  locale: StringOperationFilterInput
  regionCode: StringOperationFilterInput
  title: StringOperationFilterInput
  year: StringOperationFilterInput
  titleSlug: StringOperationFilterInput
}

input UserContributionSortInput {
  id: SortEnumType
  userId: SortEnumType
  created: SortEnumType
  status: SortEnumType
  mediaType: SortEnumType
  externalId: SortEnumType
  externalProvider: SortEnumType
  releaseDate: SortEnumType
  asin: SortEnumType
  upc: SortEnumType
  frontImageUrl: SortEnumType
  backImageUrl: SortEnumType
  releaseTitle: SortEnumType
  releaseSlug: SortEnumType
  locale: SortEnumType
  regionCode: SortEnumType
  title: SortEnumType
  year: SortEnumType
  titleSlug: SortEnumType
}

"A connection to a list of items."
type ContributionsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [ContributionsEdge!]
  "A flattened list of the nodes."
  nodes: [UserContribution!]
}

"A connection to a list of items."
type MyContributionsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [MyContributionsEdge!]
  "A flattened list of the nodes."
  nodes: [UserContribution!]
}

type ContributionNotFoundError implements Error {
  message: String!
}

input EncodedIdOperationFilterInput {
  and: [EncodedIdOperationFilterInput!]
  or: [EncodedIdOperationFilterInput!]
  eq: EncodedIdFilter
  neq: EncodedIdFilter
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input UserContributionStatusOperationFilterInput {
  eq: UserContributionStatus
  neq: UserContributionStatus
  in: [UserContributionStatus!]
  nin: [UserContributionStatus!]
}

input ListEncodedIdFilterTypeOfUserContributionDiscFilterInput {
  all: UserContributionDiscFilterInput
  none: UserContributionDiscFilterInput
  some: UserContributionDiscFilterInput
  any: Boolean
}

input ListEncodedIdFilterTypeOfUserContributionDiscHashItemFilterInput {
  all: UserContributionDiscHashItemFilterInput
  none: UserContributionDiscHashItemFilterInput
  some: UserContributionDiscHashItemFilterInput
  any: Boolean
}

enum SortEnumType {
  ASC
  DESC
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

"An edge in a connection."
type ContributionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserContribution!
}

"An edge in a connection."
type MyContributionsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserContribution!
}

interface Error {
  message: String!
}

scalar EncodedIdFilter

input UserContributionDiscFilterInput {
  and: [UserContributionDiscFilterInput!]
  or: [UserContributionDiscFilterInput!]
  encodedId: EncodedIdOperationFilterInput
  userContribution: UserContributionFilterInput
  contentHash: StringOperationFilterInput
  format: StringOperationFilterInput
  name: StringOperationFilterInput
  slug: StringOperationFilterInput
  logsUploaded: BooleanOperationFilterInput
  existingDiscPath: StringOperationFilterInput
  items: ListEncodedIdFilterTypeOfUserContributionDiscItemFilterInput
}

input UserContributionDiscHashItemFilterInput {
  and: [UserContributionDiscHashItemFilterInput!]
  or: [UserContributionDiscHashItemFilterInput!]
  encodedId: EncodedIdOperationFilterInput
  userContribution: UserContributionFilterInput
  discHash: StringOperationFilterInput
  index: IntOperationFilterInput
  name: StringOperationFilterInput
  creationTime: DateTimeOperationFilterInput
  size: LongOperationFilterInput
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input ListEncodedIdFilterTypeOfUserContributionDiscItemFilterInput {
  all: UserContributionDiscItemFilterInput
  none: UserContributionDiscItemFilterInput
  some: UserContributionDiscItemFilterInput
  any: Boolean
}

input IntOperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input LongOperationFilterInput {
  eq: Long
  neq: Long
  in: [Long]
  nin: [Long]
  gt: Long
  ngt: Long
  gte: Long
  ngte: Long
  lt: Long
  nlt: Long
  lte: Long
  nlte: Long
}

input UserContributionDiscItemFilterInput {
  and: [UserContributionDiscItemFilterInput!]
  or: [UserContributionDiscItemFilterInput!]
  encodedId: EncodedIdOperationFilterInput
  disc: UserContributionDiscFilterInput
  name: StringOperationFilterInput
  source: StringOperationFilterInput
  duration: StringOperationFilterInput
  size: StringOperationFilterInput
  chapterCount: IntOperationFilterInput
  segmentCount: IntOperationFilterInput
  segmentMap: StringOperationFilterInput
  type: StringOperationFilterInput
  description: StringOperationFilterInput
  season: StringOperationFilterInput
  episode: StringOperationFilterInput
  chapters: ListEncodedIdFilterTypeOfUserContributionChapterFilterInput
  audioTracks: ListEncodedIdFilterTypeOfUserContributionAudioTrackFilterInput
}

input ListEncodedIdFilterTypeOfUserContributionChapterFilterInput {
  all: UserContributionChapterFilterInput
  none: UserContributionChapterFilterInput
  some: UserContributionChapterFilterInput
  any: Boolean
}

input ListEncodedIdFilterTypeOfUserContributionAudioTrackFilterInput {
  all: UserContributionAudioTrackFilterInput
  none: UserContributionAudioTrackFilterInput
  some: UserContributionAudioTrackFilterInput
  any: Boolean
}

input UserContributionChapterFilterInput {
  and: [UserContributionChapterFilterInput!]
  or: [UserContributionChapterFilterInput!]
  encodedId: EncodedIdOperationFilterInput
  index: IntOperationFilterInput
  title: StringOperationFilterInput
  item: UserContributionDiscItemFilterInput
}

input UserContributionAudioTrackFilterInput {
  and: [UserContributionAudioTrackFilterInput!]
  or: [UserContributionAudioTrackFilterInput!]
  encodedId: EncodedIdOperationFilterInput
  index: IntOperationFilterInput
  title: StringOperationFilterInput
  item: UserContributionDiscItemFilterInput
}

input HashDiscRequestInput {
  files: [FileHashInfoInput!]!
}

type HashDiscResponse {
  discHash: String!
}

input ContributionMutationRequestInput {
  mediaType: String!
  externalId: String!
  externalProvider: String!
  releaseDate: DateTime!
  asin: String!
  upc: String!
  frontImageUrl: String!
  backImageUrl: String
  releaseTitle: String!
  releaseSlug: String!
  regionCode: String!
  locale: String!
  title: String!
  year: String!
  storageId: UUID!
  status: UserContributionStatus!
}

scalar UUID

input FileHashInfoInput {
  index: Int!
  name: String
  creationTime: DateTime!
  size: Long!
}

input AddContributionInput {
  input: ContributionMutationRequestInput!
}

type AddContributionPayload {
  userContribution: UserContribution
}

input HashDiscInput {
  contributionId: String!
  input: HashDiscRequestInput!
}

union HashDiscError = ContributionNotFoundError

type HashDiscPayload {
  hashDiscResponse: HashDiscResponse
  errors: [HashDiscError!]
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize("The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field." assumedSize: Int "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments." slicingArguments: [String!] "The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query." slicingArgumentDefaultValue: Int "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields." sizedFields: [String!] "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error." requireOneSlicingArgument: Boolean! = true) on FIELD_DEFINITION